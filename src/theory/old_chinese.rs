use lazy_regex::regex;
use lazy_static::lazy_static;

use crate::definition::{觸鍵方式, 輸入方案定義, 轉寫法定義, 鍵位定義};
use crate::gear::layout::{
    上檔盤面, 基本盤面, 大寫字母盤面, 盤面定義, 盤面選擇碼, 配列, 鍵盤佈局, 鍵面刻印,
};
use crate::key_code::KeyCode;
use crate::spelling_algebra::拼寫運算;
use crate::{盤面, 變換, 鍵面};

macro_rules! 鍵位 {
    ($輸入碼: ident => $鍵碼: path) => {
        鍵位定義 {
            輸入碼: stringify!($輸入碼),
            鍵碼: $鍵碼,
        }
    };
}

const 並擊鍵序: &[鍵位定義] = &[
    鍵位!(心 => KeyCode::A),
    鍵位!(清 => KeyCode::Q),
    鍵位!(精 => KeyCode::Z),
    鍵位!(曉 => KeyCode::S),
    鍵位!(來 => KeyCode::W),
    鍵位!(匣 => KeyCode::X),
    鍵位!(羣 => KeyCode::D),
    鍵位!(定 => KeyCode::E),
    鍵位!(並 => KeyCode::C),
    鍵位!(見 => KeyCode::F),
    鍵位!(端 => KeyCode::R),
    鍵位!(幫 => KeyCode::V),
    鍵位!(溪 => KeyCode::G),
    鍵位!(透 => KeyCode::T),
    鍵位!(滂 => KeyCode::B),
    鍵位!(魚 => KeyCode::Space),
    鍵位!(支 => KeyCode::H),
    鍵位!(侯 => KeyCode::Y),
    鍵位!(之 => KeyCode::N),
    鍵位!(脂 => KeyCode::J),
    鍵位!(幽 => KeyCode::U),
    鍵位!(微 => KeyCode::M),
    鍵位!(蒸 => KeyCode::K),
    鍵位!(文 => KeyCode::I),
    鍵位!(深 => KeyCode::Comma),
    鍵位!(職 => KeyCode::L),
    鍵位!(物 => KeyCode::O),
    鍵位!(緝 => KeyCode::Dot),
    鍵位!(代 => KeyCode::Semicolon),
    鍵位!(隊 => KeyCode::P),
    鍵位!(內 => KeyCode::Slash),
];

lazy_static! {
    static ref 並擊碼表示: Box<[拼寫運算::<'static>]> = Box::new([
        變換!("精匣", "莊"),
        變換!("清來定", "崇"),
        變換!("清來", "初"),
        變換!("心曉羣", "俟"),
        變換!("心曉", "生"),
        變換!("精幫", "章"),
        變換!("清定端", "常"),
        變換!("清端", "昌"),
        變換!("心羣見", "船"),
        變換!("心見", "書"),
        變換!("清定", "從"),
        變換!("心羣", "邪"),
        變換!("並幫", "明"),
        變換!("來定端", "娘"),
        變換!("定端", "泥"),
        變換!("來端", "知"),
        變換!("來透", "徹"),
        變換!("來定", "澄"),
        變換!("曉羣見", "日"),
        變換!("羣見", "疑"),
        變換!("^([魚支侯之脂幽微蒸文深職物緝代隊內])", "影$1"),
        變換!("魚幽職", "藥"),
        變換!("魚幽代", "豹"),
        變換!("魚幽", "宵"),
        變換!("魚文", "元"),
        變換!("魚物", "月"),
        變換!("魚蒸", "陽"),
        變換!("魚微", "歌"),
        變換!("魚職", "鐸"),
        變換!("幽職", "覺"),
        變換!("支職", "錫"),
        變換!("魚深", "談"),
        變換!("侯職", "屋"),
        變換!("支蒸", "耕"),
        變換!("脂職", "質"),
        變換!("脂文", "真"),
        變換!("幽蒸", "終"),
        變換!("支緝", "盍"),
        變換!("侯蒸", "東"),
    ]);
    static ref 並擊碼鍵位: Box<[拼寫運算<'static>]> = Box::new([
        變換!("莊", "精匣"),
        變換!("崇", "清來定"),
        變換!("初", "清來"),
        變換!("俟", "心曉羣"),
        變換!("生", "心曉"),
        變換!("章", "精幫"),
        變換!("常", "清定端"),
        變換!("昌", "清端"),
        變換!("船", "心羣見"),
        變換!("書", "心見"),
        變換!("從", "清定"),
        變換!("邪", "心羣"),
        變換!("明", "並幫"),
        變換!("娘", "來定端"),
        變換!("泥", "定端"),
        變換!("知", "來端"),
        變換!("徹", "來透"),
        變換!("澄", "來定"),
        變換!("日", "曉羣見"),
        變換!("疑", "羣見"),
        變換!("影", ""),
        變換!("藥", "魚幽職"),
        變換!("豹", "魚幽代"),
        變換!("宵", "魚幽"),
        變換!("元", "魚文"),
        變換!("月", "魚物"),
        變換!("陽", "魚蒸"),
        變換!("歌", "魚微"),
        變換!("鐸", "魚職"),
        變換!("覺", "幽職"),
        變換!("錫", "支職"),
        變換!("談", "魚深"),
        變換!("屋", "侯職"),
        變換!("耕", "支蒸"),
        變換!("質", "脂職"),
        變換!("真", "脂文"),
        變換!("終", "幽蒸"),
        變換!("盍", "支緝"),
        變換!("東", "侯蒸"),
    ]);
}

const 上古漢語拼音盤面: 盤面定義<'static> = 盤面![
    [ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ],
    [ 清 來 定 端 透 侯 幽 文 物 隊 _ _ ],
    [ 心 曉 羣 見 溪 支 脂 蒸 職 代 _ _ ],
    [ 精 匣 並 幫 滂 之 微 深 緝 內 ],
    [ 魚 _ 魚 ]
];

const 上古漢語並擊佈局: 鍵盤佈局 = 鍵盤佈局 {
    盤面: &[基本盤面, 上檔盤面, 大寫字母盤面, 上古漢語拼音盤面],
    默認盤面: 盤面選擇碼(4),
    首選配列: 配列::正交直列,
};

pub fn 上古漢語輸入方案() -> 輸入方案定義<'static> {
    輸入方案定義 {
        名稱: "上古漢語",
        佈局: &上古漢語並擊佈局,
        指法: 觸鍵方式::並擊,
        字根表: 並擊鍵序,
        轉寫法: 轉寫法定義 {
            輸入碼表示: &並擊碼表示,
            輸入碼鍵位: &並擊碼鍵位,
            拼式轉寫規則: &[],
            字根拆分規則: &[],
            拼式驗證規則: &[],
        },
    }
}
