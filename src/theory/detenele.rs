use lazy_regex::{regex, Regex};
use lazy_static::lazy_static;

use crate::definition::{
    動態切換規則, 碼表格式, 觸鍵方式, 輸入方案定義, 轉寫法定義, 邊界判定規則, 鍵位定義,
};
use crate::gear::layout::{
    上檔盤面, 基本盤面, 盤面定義, 盤面選擇碼, 配列, 鍵盤佈局, 鍵面刻印
};
use crate::key_code::KeyCode;
use crate::spelling_algebra::拼寫運算;
use crate::{盤面, 變換, 鍵面};

macro_rules! 鍵位 {
    ($輸入碼: ident => $盤面: expr, $鍵碼: path) => {
        鍵位定義 {
            輸入碼: stringify!($輸入碼),
            盤面: $盤面,
            鍵碼: $鍵碼,
        }
    };
    ($輸入碼: expr => $盤面: expr, $鍵碼: path) => {
        鍵位定義 {
            輸入碼: $輸入碼,
            盤面: $盤面,
            鍵碼: $鍵碼,
        }
    };
}

const 聲母盤: 盤面選擇碼 = 盤面選擇碼(1 << 1);
const 韻母盤: 盤面選擇碼 = 盤面選擇碼(1 << 2);

const 注音聲母: &[鍵位定義] = &[
    鍵位!(〇 => 聲母盤, KeyCode::Q),
    鍵位!(ㄅ => 聲母盤, KeyCode::W),
    鍵位!(ㄆ => 聲母盤, KeyCode::E),
    鍵位!(ㄇ => 聲母盤, KeyCode::R),
    鍵位!(ㄈ => 聲母盤, KeyCode::T),
    鍵位!(ㄉ => 聲母盤, KeyCode::Y),
    鍵位!(ㄊ => 聲母盤, KeyCode::U),
    鍵位!(ㄋ => 聲母盤, KeyCode::I),
    鍵位!(ㄌ => 聲母盤, KeyCode::O),
    鍵位!(ㄍ => 聲母盤, KeyCode::A),
    鍵位!(ㄎ => 聲母盤, KeyCode::S),
    鍵位!(ㄏ => 聲母盤, KeyCode::D),
    鍵位!(ㄐ => 聲母盤, KeyCode::F),
    鍵位!(ㄑ => 聲母盤, KeyCode::G),
    鍵位!(ㄒ => 聲母盤, KeyCode::H),
    鍵位!(ㄓ => 聲母盤, KeyCode::Z),
    鍵位!(ㄔ => 聲母盤, KeyCode::X),
    鍵位!(ㄕ => 聲母盤, KeyCode::C),
    鍵位!(ㄖ => 聲母盤, KeyCode::V),
    鍵位!(ㄗ => 聲母盤, KeyCode::B),
    鍵位!(ㄘ => 聲母盤, KeyCode::N),
    鍵位!(ㄙ => 聲母盤, KeyCode::M),
];
const 注音韻母: &[鍵位定義] = &[
    // 兩個盤面都有介音
    鍵位!(ㄧ => 聲母盤, KeyCode::J),
    鍵位!(ㄨ => 聲母盤, KeyCode::K),
    鍵位!(ㄩ => 聲母盤, KeyCode::L),
    鍵位!(ㄧ => 韻母盤, KeyCode::J),
    鍵位!(ㄨ => 韻母盤, KeyCode::K),
    鍵位!(ㄩ => 韻母盤, KeyCode::L),
    鍵位!(ㄚ => 韻母盤, KeyCode::W),
    鍵位!(ㄛ => 韻母盤, KeyCode::E),
    鍵位!(ㄜ => 韻母盤, KeyCode::R),
    鍵位!(ㄝ => 韻母盤, KeyCode::T),
    鍵位!(ㄞ => 韻母盤, KeyCode::Y),
    鍵位!(ㄟ => 韻母盤, KeyCode::U),
    鍵位!(ㄠ => 韻母盤, KeyCode::I),
    鍵位!(ㄡ => 韻母盤, KeyCode::O),
    鍵位!(ㄢ => 韻母盤, KeyCode::S),
    鍵位!(ㄣ => 韻母盤, KeyCode::D),
    鍵位!(ㄤ => 韻母盤, KeyCode::F),
    鍵位!(ㄥ => 韻母盤, KeyCode::G),
    鍵位!(ㄦ => 韻母盤, KeyCode::H),
];

const 聲調符號: &[鍵位定義] = &[
    鍵位!(ˉ => 韻母盤, KeyCode::V),
    鍵位!(ˊ => 韻母盤, KeyCode::B),
    鍵位!(ˇ => 韻母盤, KeyCode::N),
    鍵位!(ˋ => 韻母盤, KeyCode::M),
    鍵位!("˙" => 韻母盤, KeyCode::P),
];

lazy_static! {
    static ref 字根表: Vec<鍵位定義<'static>> = [
        注音聲母,
        注音韻母,
        聲調符號,
    ].concat();

    static ref 動態注音碼轉寫成標準注音文: Box<[拼寫運算::<'static>]> = Box::new([
        // 零聲母符號不寫，直接寫韻母
        變換!("^〇([ㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦ])", "${1}"),
    ]);

    static ref 標準注音文拆分成動態注音碼: Box<[拼寫運算::<'static>]> = Box::new([
        // 添加零聲母符號
        變換!("^([ㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦ])", "〇${1}"),
    ]);

    static ref 注音拼式: Box<[&'static Regex]> = Box::new([
        regex!("^[〇ㄅㄆㄇㄈㄉㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙ]?[ㄧㄨㄩ]?[ㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦ]?[ˉˊˇˋ˙]?$").deref(),
    ]);

    static ref 錄畢聲母: &'static Regex = regex!("^[ㄅㄆㄇㄈㄉㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙ〇ㄧㄨㄩ]").deref();
    static ref 聲調結尾: &'static Regex = regex!("^.*[ˉˊˇˋ˙]$").deref();

    static ref 動態切換表: Box<[動態切換規則<'static>]> = Box::new([
        動態切換規則 {
            匹配輸入: &聲調結尾,
            目標盤面: 聲母盤,
        },
        動態切換規則 {
            匹配輸入: &錄畢聲母,
            目標盤面: 韻母盤,
        },
    ]);
}

const 注音聲母盤面: 盤面定義<'static> = 盤面! {
    [],
    [ 〇 ㄅ ㄆ ㄇ ㄈ ㄉ ㄊ ㄋ ㄌ 空 ],
    [ ㄍ ㄎ ㄏ ㄐ ㄑ ㄒ ㄧ ㄨ ㄩ _ ],
    [ ㄓ ㄔ ㄕ ㄖ ㄗ ㄘ ㄙ _ _ ],
    [ _ _ _ ]
};

const 注音韻母盤面: 盤面定義<'static> = 盤面! {
    [],
    [ 空 ㄚ ㄛ ㄜ ㄝ ㄞ ㄟ ㄠ ㄡ "˙" ],
    [ 空 ㄢ ㄣ ㄤ ㄥ ㄦ ㄧ ㄨ ㄩ _ ],
    [ 空 空 空 ˉ ˊ ˇ ˋ _ _ ],
    [ _ _ _ ]
};

const 動態能力注音鍵盤佈局: 鍵盤佈局 = 鍵盤佈局 {
    盤面: &[基本盤面, 上檔盤面, 注音聲母盤面, 注音韻母盤面],
    默認盤面: 聲母盤,
    首選配列: 配列::字母鍵盤,
};

pub fn 動態能力注音輸入方案() -> 輸入方案定義<'static> {
    輸入方案定義 {
        名稱: "動態能力注音",
        佈局: &動態能力注音鍵盤佈局,
        指法: 觸鍵方式::連擊,
        編碼法: 碼表格式::連擊,
        字根表: &字根表,
        轉寫法: 轉寫法定義 {
            輸入碼表示: &[],
            輸入碼鍵位: &[],
            拼式轉寫規則: &動態注音碼轉寫成標準注音文,
            字根拆分規則: &標準注音文拆分成動態注音碼,
            拼式驗證規則: &注音拼式,
            邊界判定: 邊界判定規則 {
                分隔鍵: &[],
                起始鍵: 注音聲母,
                終止鍵: 聲調符號,
            },
        },
        動態切換: &動態切換表,
    }
}
