use keyberon::key_code::KeyCode;
use leptos::logging::log;
use leptos::prelude::*;

use crate::action::動作;
use crate::definition::{觸鍵方式, 輸入方案定義, 鍵組};
use crate::gear::{
    assignment::{作業, 作業推進參數, 作業機關},
    caption::{字幕機關, 字幕段落, 字幕表示},
    chord::{並擊機關, 並擊狀態},
    input::{焦點事件處理機關, 輸入事件處理機關},
    key_press::連擊機關,
    mode::{工作模式, 工作模式機關},
    theory::{方案選項, 輸入方案機關},
};

#[allow(clippy::type_complexity)]
pub fn 微觀引擎() -> (
    // 反查鍵位
    Signal<Option<鍵組>>,
    // 有無輸入碼
    Signal<bool>,
    // 指法
    Signal<觸鍵方式>,
    // 並擊狀態流
    ReadSignal<並擊狀態>,
    // 現行工作模式
    ReadSignal<工作模式>,
    // 字幕段落表示
    Signal<Option<字幕表示>>,
    // 輸入正確
    Signal<bool>,
    // 當前作業
    ReadSignal<作業>,
    // 佈置作業
    WriteSignal<作業>,
    // 回顯輸入碼
    Signal<String>,
    // 回顯轉寫碼
    Signal<Option<String>>,
    // 現行方案
    ReadSignal<方案選項>,
    // 選用方案
    WriteSignal<方案選項>,
    // 方案定義
    Signal<輸入方案定義<'static>>,
    // 開啓練習題選單
    impl 動作,
    // 開啓反查輸入
    impl 動作,
    // 關閉輸入欄
    impl 動作,
) {
    let (現行方案, 選用方案, 方案定義) = 輸入方案機關();

    let 指法 = Signal::derive(move || 方案定義.read().指法);

    let (
        當前作業,
        佈置作業,
        有無作業,
        作業進度,
        作業進度完成,
        反查輸入碼序列,
        目標輸入碼,
        重置作業進度,
        作業推進,
        作業回退,
    ) = 作業機關(現行方案, 方案定義);

    let (分段字幕, 當前段落, 字幕段落表示) = 字幕機關(當前作業, 作業進度, 反查輸入碼序列, 指法);

    let (
        _連擊狀態流,
        連擊狀態變更,
        實況字根碼,
        連擊比對成功,
        連擊輸入碼,
        編輯連擊輸入碼,
        清空連擊輸入碼,
        回退連擊輸入碼,
    ) = 連擊機關(方案定義, 目標輸入碼);

    let (
        並擊狀態流,
        並擊狀態變更,
        實況並擊碼,
        並擊所得拼音,
        反查所得並擊碼,
        反查鍵位,
        _並擊開始,
        並擊完成,
        並擊成功,
        重置並擊狀態,
    ) = 並擊機關(方案定義, 目標輸入碼);

    let 重置輸入狀態 = move || match 指法() {
        觸鍵方式::連擊 => 清空連擊輸入碼(),
        觸鍵方式::並擊 => 重置並擊狀態(),
    };

    let (現行工作模式, 開啓反查輸入, 開啓練習題選單, 開啓方案選單, 關閉輸入欄) =
        工作模式機關(現行方案, 作業進度完成, 佈置作業, 重置作業進度, 重置輸入狀態);

    let _ = Effect::watch(
        現行工作模式,
        move |新, 舊, _| {
            log!("工作模式: {:?} -> {:?}", 舊, 新);
        },
        false,
    );

    焦點事件處理機關(重置並擊狀態);

    let 處理功能鍵 = move |鍵碼: KeyCode| match 鍵碼 {
        KeyCode::Escape => {
            match 現行工作模式() {
                工作模式::錄入 => {
                    if 作業進度() != 0 {
                        重置作業進度();
                        重置輸入狀態();
                    } else {
                        開啓練習題選單();
                    }
                }
                _ => 關閉輸入欄(),
            }
            true
        }
        KeyCode::Tab => {
            if 現行工作模式() == 工作模式::錄入 {
                if 作業推進(作業推進參數 {
                    段落: 當前段落().map(|字幕段落(起, 止, _)| (起, 止)),
                    迴轉: true,
                })
                .is_ok()
                {
                    重置輸入狀態();
                }
            } else {
                關閉輸入欄();
            }
            true
        }
        KeyCode::BSpace => {
            if 現行工作模式() == 工作模式::錄入 {
                match 指法() {
                    觸鍵方式::連擊 => {
                        if 有無作業() {
                            let _不看結果 = 作業回退();
                        }
                        回退連擊輸入碼();
                    }
                    觸鍵方式::並擊 => {
                        if 並擊完成() || 作業回退().is_ok() {
                            重置並擊狀態();
                        }
                    }
                }
                return true;
            }
            false
        }
        KeyCode::Enter => {
            if 現行工作模式() == 工作模式::錄入 {
                開啓反查輸入();
            } else {
                關閉輸入欄();
            }
            true
        }
        KeyCode::Grave => {
            match 現行工作模式() {
                工作模式::選擇輸入方案 => 關閉輸入欄(),
                _ => 開啓方案選單(),
            }
            true
        }
        _ => false,
    };

    let 擊中目標 = move || match 指法() {
        觸鍵方式::連擊 => 連擊比對成功(),
        觸鍵方式::並擊 => 並擊完成() && 並擊成功(),
    };
    let 批閱作業 = move || {
        // 擊中目標輸入碼後反查下一個輸入碼
        let 分段落則迴轉 = 分段字幕.read().len() > 1;
        擊中目標() && 作業推進(作業推進參數::步進(分段落則迴轉)).is_ok()
    };
    let 另起一段 = move || {
        當前段落
            .read()
            .as_ref()
            .is_some_and(|字幕段落(段落起始, _, _)| 作業進度.read() == *段落起始)
    };
    let 既然落鍵 = move |鍵碼| {
        // 繼續擊鍵時消除已完成的反查作業
        if 作業進度完成() {
            佈置作業(作業::自習(現行方案()));
        }
        if 現行工作模式() == 工作模式::錄入 {
            並擊狀態變更.write().落鍵(鍵碼);
            if 指法() == 觸鍵方式::連擊 {
                連擊狀態變更.write().擊發(鍵碼);
                編輯連擊輸入碼(鍵碼);
                if 批閱作業() && 另起一段() {
                    清空連擊輸入碼();
                }
            }
        }
    };
    let 既然抬鍵 = move |鍵碼| {
        if 現行工作模式() == 工作模式::錄入 {
            並擊狀態變更.write().抬鍵(鍵碼);
        }
        match 指法() {
            觸鍵方式::連擊 => {
                // 顯示並擊動態, 抬鍵後清除並擊結果
                if 並擊完成() && !作業進度完成() {
                    重置並擊狀態();
                }
            }
            觸鍵方式::並擊 => {
                // 推進到下一題時, 清除上一題的並擊結果
                // 但在最後一題完成後停下顯示結果
                if 批閱作業() && !作業進度完成() {
                    重置並擊狀態();
                }
            }
        }
    };

    輸入事件處理機關(處理功能鍵, 既然落鍵, 既然抬鍵);

    let 有無輸入碼 = Signal::derive(move || match 指法() {
        觸鍵方式::連擊 => !實況字根碼().is_empty(),
        觸鍵方式::並擊 => !實況並擊碼().is_empty(),
    });
    let 完成一詞 = move || {
        字幕段落表示
            .read()
            .as_ref()
            .is_some_and(|字幕表示 { 指標文字, .. }| ["", " "].contains(&指標文字.as_str()))
    };
    let 輸入正確 = Signal::derive(move || match 指法() {
        觸鍵方式::連擊 => 完成一詞(),
        觸鍵方式::並擊 => 並擊完成() && 並擊成功(),
    });
    let 回顯輸入碼 = Signal::derive(move || match 指法() {
        觸鍵方式::連擊 => {
            let 輸入碼 = 連擊輸入碼.read().join("");
            match 輸入碼.as_str() {
                "" | "␣" => 輸入碼,
                _ => 輸入碼 + "‸",
            }
        }
        觸鍵方式::並擊 => 反查所得並擊碼().unwrap_or_else(實況並擊碼),
    });
    let 回顯轉寫碼 = Signal::derive(move || match 指法() {
        觸鍵方式::連擊 => None,
        觸鍵方式::並擊 => {
            目標輸入碼()
                .and_then(|輸入碼| 輸入碼.轉寫碼原文)
                .or_else(|| 並擊所得拼音().to_owned())
                // 加尖括弧表示拉丁文轉寫
                .map(|轉寫| format!("⟨{轉寫}⟩"))
        }
    });

    (
        反查鍵位,
        有無輸入碼,
        指法,
        並擊狀態流,
        現行工作模式,
        字幕段落表示,
        輸入正確,
        當前作業,
        佈置作業,
        回顯輸入碼,
        回顯轉寫碼,
        現行方案,
        選用方案,
        方案定義,
        開啓練習題選單,
        開啓反查輸入,
        關閉輸入欄,
    )
}
