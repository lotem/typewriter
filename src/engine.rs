use leptos::logging::log;
use leptos::prelude::*;

use crate::action::动作;
use crate::definition::击键方式;
use crate::gear::{
    assignment::{ 作业模式输出信号, 作业, 作业模式, 步进设置 },
    caption::{ 字幕机关, 字幕机关输出信号, 字幕段落 },
    chord::{ 并击模式, 并击模式输出信号 },
    input::{ 焦点事件处理机关, 击键消息, 输入事件处理机关 },
    key_press::{ 连击模式输出信号, 连击机关 },
    layout::{ 配列机关, 键盘配列输出信号 },
    mode::{ 工作模式, 工作模式机关, 工作模式输出信号 },
    theory::{ 输入方案, 输入方案输出信号 },
};
use crate::key_code::KeyCode;

#[derive(Clone)]
pub struct 微观引擎输出信号 {
    pub 方案: 输入方案输出信号,
    pub 模式: 工作模式输出信号,
    pub 键盘配列: 键盘配列输出信号,
    pub 作业: 作业模式输出信号,
    pub 字幕: 字幕机关输出信号,
    pub 连击: 连击模式输出信号,
    pub 并击: 并击模式输出信号,
}

pub fn 微观引擎() -> 微观引擎输出信号 {
    let 方案 = 输入方案();
    let 键盘配列 = 配列机关(&方案);
    let 作业 = 作业模式(&方案);
    let 字幕 = 字幕机关(&方案, &作业);
    let 连击 = 连击机关(&方案, &作业);
    let 并击 = 并击模式(&方案, &作业);

    let 输入方案输出信号 { 当前方案, 指法, .. } = 方案;
    let 作业模式输出信号 {
        布置作业,
        作业进度,
        重置作业进度,
        作业完成,
        作业推进,
        作业回退,
        有无作业,
        ..
    } = 作业;
    let 字幕机关输出信号 { 分段字幕, 当前段落, 前序段落, .. } = 字幕;
    let 连击模式输出信号 {
        连击状态变更,
        连击比对成功,
        清空连击输入码,
        回退连击输入码,
        编辑连击输入码,
        ..
    } = 连击;
    let 并击模式输出信号 { 并击状态变更, 重置并击状态, 并击完成, 并击成功, .. } = 并击;

    let 输入 = 输入动作机关(&方案, &连击, &并击);

    let 模式 = 工作模式机关(&方案, &作业, &输入);

    let 输入动作 { 重置输入状态 } = 输入;

    let 工作模式输出信号 {
        现行工作模式,
        开启反查输入,
        开启练习题选单,
        开启方案选单,
        开启配列选单,
        关闭输入栏,
        ..
    } = 模式;

    let _ = Effect::watch(
        现行工作模式,
        move |新, 旧, _| {
            log!("工作模式: {:?} -> {:?}", 旧, 新);
        },
        false
    );

    焦点事件处理机关(重置并击状态);

    let 处理功能键 = move |击键消息 { 键码, 档位 }| {
        match 键码 {
            KeyCode::Escape => {
                match 现行工作模式() {
                    工作模式::录入 => {
                        if 作业进度() != 0 {
                            重置作业进度();
                            重置输入状态();
                        } else {
                            开启练习题选单();
                        }
                    }
                    _ => 关闭输入栏(),
                }
                true
            }
            KeyCode::Tab => {
                match 现行工作模式() {
                    工作模式::录入 => {
                        let 跳转结果 = if 档位.shift {
                            let 目标 = 前序段落()
                                .or_else(|| 分段字幕.with(|众段落| 众段落.last().cloned()))
                                .map(|字幕段落(起, _, _)| 起);
                            作业回退(步进设置 {
                                目标,
                                循环: true,
                            })
                        } else {
                            let 目标 = 当前段落().map(|字幕段落(_, 止, _)| 止);
                            作业推进(步进设置 {
                                目标,
                                循环: true,
                            })
                        };
                        if 跳转结果.is_ok() {
                            重置输入状态();
                        }
                    }
                    工作模式::选取练习题 => {
                        开启方案选单();
                    }
                    工作模式::选择输入方案 => {
                        开启配列选单();
                    }
                    工作模式::选择配列 => {
                        开启练习题选单();
                    }
                    _ => {
                        关闭输入栏();
                    }
                }
                true
            }
            KeyCode::Backspace => {
                if 现行工作模式() == 工作模式::录入 {
                    match 指法() {
                        击键方式::连击 => {
                            if 有无作业() {
                                let _不看结果 = 作业回退(步进设置::default());
                            }
                            回退连击输入码();
                        }
                        击键方式::并击 => {
                            if 并击完成() || 作业回退(步进设置::default()).is_ok() {
                                重置并击状态();
                            }
                        }
                    }
                    return true;
                }
                false
            }
            KeyCode::Enter => {
                if 现行工作模式() == 工作模式::录入 {
                    开启反查输入();
                } else {
                    关闭输入栏();
                }
                true
            }
            KeyCode::Grave => {
                match 现行工作模式() {
                    工作模式::选择输入方案 => 关闭输入栏(),
                    _ => 开启方案选单(),
                }
                true
            }
            _ => false,
        }
    };

    let 击中目标 = move || {
        match 指法() {
            击键方式::连击 => 连击比对成功(),
            击键方式::并击 => 并击完成() && 并击成功(),
        }
    };
    let 批阅作业 = move || {
        // 击中目标输入码后反查下一个输入码
        let 分段落则回转 = 步进设置 {
            目标: None,
            循环: 分段字幕.read().len() > 1,
        };
        击中目标() && 作业推进(分段落则回转).is_ok()
    };
    let 另起一段 = move || {
        当前段落.read()
            .as_ref()
            .is_some_and(|字幕段落(段落起始, _, _)| 作业进度.read() == *段落起始)
    };
    let 既然落键 = move |键码| {
        // 继续击键时消除已完成的反查作业
        if 作业完成() {
            布置作业(作业::自习(当前方案()));
        }
        if 现行工作模式() == 工作模式::录入 {
            并击状态变更.write().落键(键码);
            if 指法() == 击键方式::连击 {
                连击状态变更.write().击发(键码);
                编辑连击输入码(键码);
                if 批阅作业() && 另起一段() {
                    清空连击输入码();
                }
            }
        }
    };
    let 既然擡键 = move |键码| {
        if 现行工作模式() == 工作模式::录入 {
            并击状态变更.write().抬键(键码);
        }
        match 指法() {
            击键方式::连击 => {
                // 显示并击动态, 擡键后清除并击结果
                if 并击完成() {
                    重置并击状态();
                }
            }
            击键方式::并击 => {
                // 推进到下一题时, 清除上一题的并击结果
                // 但在最后一题完成后停下显示结果
                if 批阅作业() && !作业完成() {
                    重置并击状态();
                }
            }
        }
    };

    输入事件处理机关(处理功能键, 既然落键, 既然擡键);

    微观引擎输出信号 {
        方案,
        模式,
        键盘配列,
        作业,
        字幕,
        连击,
        并击,
    }
}

pub type 输入重置动作 = impl 动作;

#[derive(Clone)]
pub struct 输入动作 {
    pub 重置输入状态: 输入重置动作,
}

#[define_opaque(输入重置动作)]
fn 输入动作机关(
    方案: &输入方案输出信号,
    连击: &连击模式输出信号,
    并击: &并击模式输出信号
) -> 输入动作 {
    let 指法 = 方案.指法;
    let 清空连击输入码 = 连击.清空连击输入码;
    let 重置并击状态 = 并击.重置并击状态;

    let 重置输入状态 = move || {
        match 指法() {
            击键方式::连击 => 清空连击输入码(),
            击键方式::并击 => 重置并击状态(),
        }
    };

    输入动作 { 重置输入状态 }
}
